

# Практическая работа № 14

## Автор
Курков Владислав Николаевич
ПИМО-01-25

## Задание
Оптимизация запросов к БД. Использование connection pool.

**Цели:**
1. Научиться находить «узкие места» в SQL-запросах и устранять их (индексы, переписывание запросов, пагинация, батчинг).
2. Освоить настройку пула подключений (connection pool) в Go и параметры его тюнинга.
3. Научиться использовать EXPLAIN/ANALYZE, базовые метрики (pg_stat_statements), подготовленные запросы и транзакции.
4. Применить техники уменьшения N+1 запросов и сокращения аллокаций на горячем пути.

## Подготовка к запуску

### Клонирование репозитория
```bash
git clone https://github.com/MrFandore/Goland.git
cd Goland/Practica_14
```

### Структура проекта
```
├── README.md
├── cmd
│   └── api
│       └── main.go
├── docker-compose.yaml
├── go.mod
├── go.sum
└── internal
    ├── config
    │   └── config.go
    ├── model
    │   └── note.go
    ├── pagination
    │   └── cursor.go
    ├── storage
    │   ├── postgres
    │   │   ├── queries.go
    │   │   └── repo.go
    │   └── redis
    │       └── cache.go
    └── transport
        └── http
            ├── handlers.go
            ├── respond.go
            └── server.go
```

### Конфигурация (.env)
Создайте файл `.env` в корне проекта:

```env
# Remote Postgres
DB_DSN=postgres://root:root@http://address:5432/pz9_bcrypt?sslmode=disable

# HTTP
HTTP_ADDR=:8087

# Redis (локально через docker compose)
REDIS_ADDR=127.0.0.1:6379
REDIS_PASSWORD=kek
REDIS_DB=0
CACHE_TTL_SECONDS=45
```

### Запуск проекта
```bash
# Запуск Redis через Docker Compose
docker-compose up -d

# Запуск приложения
go run ./cmd/api
```

### Проверка работоспособности
![Проверка запуска](Imagine/img.png)
![Проверка API](Imagine/img_1.png)

## Примеры запросов к API

### 1. Создание заметки
```bash
curl -s -X POST http://178.72.139.210:8087/notes \
  -H 'Content-Type: application/json' \
  -d '{"title":"redis tips","content":"..."}'
```
Результат:

![Создание заметки](Imagine/img_2.png)

### 2. Получение заметки по ID (с кэшированием)
```bash
# Первый запрос — из базы данных
curl -s http://178.72.139.210:8087/notes/1
# Второй запрос — из Redis (кэш)
curl -s http://178.72.139.210:8087/notes/1
```
Результат:

![Получение заметки с кэшированием](Imagine/img_3.png)

### 3. Список с keyset-пагинацией и полнотекстовым поиском
```bash
# Первая страница
curl -s "http://178.72.139.210:8087/notes?limit=20&q=redis"

# Вторая страница (с курсором)
curl -s "http://178.72.139.210:8087/notes?limit=20&q=redis&cursor=eyJjcmVhdGVkX2F0IjoiMjAyNS0xMi0xMlQxMDoyNzozNy43NjU3WiIsImlkIjoxfQ"
```
Результат:

![Пагинация и поиск](Imagine/img_6.png)

### 4. Обновление заметки
```bash
curl -s -X PATCH http://178.72.139.210:8087/notes/1 \
  -H 'Content-Type: application/json' \
  -d '{"title":"redis tips v2","content":"updated"}'
```
Результат:

![Обновление заметки](Imagine/img_4.png)

### 5. Пакетное получение заметок (батч вместо N+1)
```bash
curl -s "http://178.72.139.210:8087/notes/batch?ids=1,2,3,4"
```
Результат:

![Батч-запрос](Imagine/img_5.png)

## Оптимизации, примененные в проекте

### Выявленные проблемы до оптимизации

| Проблема | Описание | Последствия |
|----------|----------|-------------|
| **OFFSET-пагинация** | Использование `OFFSET` для пагинации | Время выполнения росло линейно с номером страницы (сканирование всех предыдущих строк) |
| **N+1 запросов** | Множество отдельных запросов по первичному ключу | Увеличение времени ответа из-за сетевых round-trips |
| **Неэффективный поиск** | Поиск по title без использования индексов | Полное сканирование таблицы (Seq Scan) |

### Примененные оптимизации

#### 1. Переписывание запросов
- **Keyset-пагинация** (cursor-based): замена `OFFSET` на пагинацию по паре `(created_at, id)`
- **Батчинг**: замена N+1 запросов на один запрос с `WHERE id = ANY($1)`
- **Полнотекстовый поиск**: приведение запросов к форме, использующей GIN-индекс

#### 2. Создание индексов
```sql
-- Композитный индекс для keyset-пагинации
CREATE INDEX idx_notes_created_at_id ON notes(created_at, id);

-- GIN-индекс для полнотекстового поиска
CREATE INDEX idx_notes_search ON notes USING gin(to_tsvector('russian', title));
```

#### 3. Настройка пула подключений (connection pool)
```go
// Конфигурация пула
config.MaxConns = 20          // Максимальное количество соединений в пуле
config.MinConns = 5           // Минимальное количество соединений (поддерживается постоянно)
config.MaxConnLifetime = 1 * time.Hour // Максимальное время жизни соединения
```

### Результаты оптимизации
- **Пагинация**: постоянное время выполнения независимо от номера страницы
- **Батч-запросы**: сокращение времени ответа в 3-5 раз для множественных запросов
- **Поиск**: ускорение в 10-50 раз благодаря индексам


## Выводы
В ходе практической работы были освоены методы оптимизации SQL-запросов и настройки пула подключений в Go-приложении. На примере учебного проекта удалось выявить и устранить типичные проблемы производительности:

1. **OFFSET-пагинация** заменена на keyset-пагинацию с использованием композитного индекса `(created_at, id)`, что обеспечило константное время выполнения независимо от глубины выборки.

2. **Проблема N+1 запросов** решена с помощью батчинга — множественные запросы по ID заменены на один запрос с оператором `ANY`, что значительно сократило сетевые задержки.

3. **Поиск по тексту** оптимизирован с помощью GIN-индекса для полнотекстового поиска, что позволило отказаться от полного сканирования таблицы.

4. **Пул подключений** настроен с оптимальными параметрами (min/max conns, lifetime), что предотвращает исчерпание соединений и снижает накладные расходы на установку новых подключений.

Дополнительно применено кэширование результатов в Redis, что позволило снизить нагрузку на базу данных для часто запрашиваемых записей. Полученные навыки являются основой для проектирования производительных и масштабируемых приложений, работающих с реляционными базами данных.